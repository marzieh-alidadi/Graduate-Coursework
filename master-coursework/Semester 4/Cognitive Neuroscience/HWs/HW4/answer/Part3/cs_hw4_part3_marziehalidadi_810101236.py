# -*- coding: utf-8 -*-
"""CS_HW4_part3_MarziehAlidadi_810101236.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VlzOauW_3dx5-h1Hyi4LOBb1yni5Siwe

**Spectral Analysis of EEG Signals**
"""

pip install numpy mne matplotlib

!pip install --upgrade mne

import os
import numpy as np
import scipy.io
import mne
from mne.time_frequency import psd_array_multitaper
import matplotlib.pyplot as plt

"""# Load and Preprocess Data

## Define file paths
"""

set_path = '/content/preprocessed_data.set'
fdt_path = '/content/preprocessed_data.fdt'

"""## Load the .set file manually to inspect its content"""

eeg_data = scipy.io.loadmat(set_path, struct_as_record=False, squeeze_me=True)
print("EEGLAB .set file content:")
for key, value in eeg_data.items():
    if not key.startswith('__'):
        print(f"{key}: {type(value)}")

"""## Extract data shape information manually

"""

nbchan = eeg_data['nbchan']
pnts = eeg_data['pnts']
trials = eeg_data['trials']
srate = eeg_data['srate']
print(f"Number of channels: {nbchan}")
print(f"Number of points per channel: {pnts}")
print(f"Number of trials: {trials}")
print(f"Sampling rate: {srate}")

"""## Load the .fdt file manually to inspect its content

"""

dataset = np.fromfile(fdt_path, dtype=np.float32)
print(f"Data size: {dataset.size}")

"""## Check if the total size matches

"""

expected_size = nbchan * pnts * trials
if dataset.size < expected_size:
    print(f"Warning: Data size ({dataset.size}) is less than expected ({expected_size}), truncating the data.")
    expected_size = dataset.size

"""## Calculate new shape based on actual data size

"""

trials_new = dataset.size // (nbchan * pnts)
print(f"Adjusted number of trials based on actual data: {trials_new}")

"""## Reshape the data manually

"""

dataset = dataset[:nbchan * pnts * trials_new]
dataset = dataset.reshape((nbchan, pnts, trials_new), order='F')
print(f"Reshaped data shape: {dataset.shape}")

"""## Create MNE Info object"""

channel_names = [f'ch{i+1}' for i in range(nbchan)]
info = mne.create_info(ch_names=channel_names, sfreq=srate, ch_types='eeg')

"""## Convert to MNE Epochs object

"""

epochs = mne.EpochsArray(dataset.transpose(2, 0, 1), info)

"""#Estimate PSD using Multitaper Method

## Apply the Multitaper method to estimate the PSD
"""

psds, freqs = psd_array_multitaper(epochs.get_data(), sfreq=epochs.info['sfreq'], fmin=0.5, fmax=100, bandwidth=4.0, adaptive=True, low_bias=True, normalization='full', n_jobs=1)

"""## Convert power to dB

"""

psds = 10 * np.log10(psds)

"""## Calculate mean and confidence intervals across epochs"""

psd_mean = np.mean(psds, axis=0)  # Shape (channels, frequencies)
psd_std = np.std(psds, axis=0)    # Same
conf_interval = 1.96 * psd_std / np.sqrt(psds.shape[0])  # Same

"""## Plot the PSD with confidence intervals

"""

fig, ax = plt.subplots(1, 1, figsize=(10, 6))
psd_mean_avg = np.mean(psd_mean, axis=0)
conf_interval_avg = np.mean(conf_interval, axis=0)

ax.plot(freqs, psd_mean_avg, label='Mean PSD')
ax.fill_between(freqs, psd_mean_avg - conf_interval_avg, psd_mean_avg + conf_interval_avg, color='gray', alpha=0.5, label='95% Confidence Interval')
ax.set_title('Power Spectral Density (PSD) using Multitaper Method')
ax.set_xlabel('Frequency (Hz)')
ax.set_ylabel('Power (dB)')
ax.legend()
plt.show()

"""#Baseline Normalization and Comparison

## Adjust baseline period to be within the range of the epoch data
"""

baseline_period = (0.0, 0.1)
epochs.apply_baseline(baseline=baseline_period)
psds_baseline, freqs = psd_array_multitaper(epochs.get_data(), sfreq=epochs.info['sfreq'], fmin=0.5, fmax=100, bandwidth=4.0, adaptive=True, low_bias=True, normalization='full', n_jobs=1)
psds_baseline = 10 * np.log10(psds_baseline)

"""## Calculate mean and confidence intervals for baseline-normalized data

"""

psd_mean_baseline = np.mean(psds_baseline, axis=0)
psd_std_baseline = np.std(psds_baseline, axis=0)
conf_interval_baseline = 1.96 * psd_std_baseline / np.sqrt(psds_baseline.shape[0])

"""## Plot PSD with and without baseline normalization"""

fig, ax = plt.subplots(2, 1, figsize=(12, 8), sharex=True)

# Before
psd_mean_avg = np.mean(psd_mean, axis=0)
conf_interval_avg = np.mean(conf_interval, axis=0)
ax[0].plot(freqs, psd_mean_avg, label='Without Baseline Normalization')
ax[0].fill_between(freqs, psd_mean_avg - conf_interval_avg, psd_mean_avg + conf_interval_avg, color='gray', alpha=0.5)
ax[0].set_title('PSD Without Baseline Normalization')
ax[0].set_ylabel('Power (dB)')
ax[0].legend()

#After
psd_mean_baseline_avg = np.mean(psd_mean_baseline, axis=0)
conf_interval_baseline_avg = np.mean(conf_interval_baseline, axis=0)
ax[1].plot(freqs, psd_mean_baseline_avg, label='With Baseline Normalization', color='red')
ax[1].fill_between(freqs, psd_mean_baseline_avg - conf_interval_baseline_avg, psd_mean_baseline_avg + conf_interval_baseline_avg, color='pink', alpha=0.5)
ax[1].set_title('PSD With Baseline Normalization')
ax[1].set_xlabel('Frequency (Hz)')
ax[1].set_ylabel('Power (dB)')
ax[1].legend()

plt.tight_layout()
plt.show()

"""#Comparison of Results"""

# Define frequency bands
frequency_bands = {
    'Delta': (0.5, 4), 'Theta': (4, 8), 'Alpha': (8, 13), 'Beta': (13, 30), 'Gamma': (30, 100)
}

# Function to calculate average power in frequency bands
def calculate_power_band(psds, freqs, band):
    frequency_bands = np.logical_and(freqs >= band[0], freqs <= band[1])
    power_band = np.mean(psds[:, :, frequency_bands], axis=(0, 2))
    return power_band

"""## Calculate band powers for non-baseline-normalized PSD

"""

power_bands = {}
for band_name, band_range in frequency_bands.items():
    power_bands[band_name] = calculate_power_band(psds, freqs, band_range)

print("Average power in frequency bands (non-baseline-normalized):")
for band_name, power in power_bands.items():
    print(f"{band_name}: {power} dB")

"""## Calculate band powers for baseline-normalized PSD

"""

power_bands_baseline = {}
for band_name, band_range in frequency_bands.items():
    power_bands_baseline[band_name] = calculate_power_band(psds_baseline, freqs, band_range)

print("\nAverage power in frequency bands (baseline-normalized):")
for band_name, power in power_bands_baseline.items():
    print(f"{band_name}: {power} dB")

"""## Compare the two results

"""

for band_name in frequency_bands.keys():
    diff = power_bands[band_name] - power_bands_baseline[band_name]
    print(f"\nDifference in {band_name} band power (non-baseline-normalized - baseline-normalized): {diff} dB")